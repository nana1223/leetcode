package jianzhi_offer;

/**
 * 剑指 Offer 14- I. 剪绳子
 * <p>
 * 要求剪的每一段乘积和最大，输出乘积和。同时所有段相加为n
 * <p>
 * <p>
 * 【思路】：由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。
 * <p>
 * 【动态规划】
 * 1.状态定义:dp[i]为长度为i的绳子剪成m段最大乘积为dp[i]
 * 2.状态转移:dp[i]有两种途径可以转移得到
 * 2.1 由前一个dp[j]*(i-j)得到,即前面剪了>=2段,后面再剪一段,此时的乘积个数>=3个
 * 2.2 前面单独成一段,后面剩下的单独成一段,乘积为j*(i-j),乘积个数为2
 * 两种情况中取大的值作为dp[i]的值,同时应该遍历所有j,j∈[1,i-1],取最大值
 * 3.初始化:初始化dp[1]=1即可
 * 4.遍历顺序:显然为正序遍历
 * 5.返回坐标:返回dp[n]
 */
public class Solution14_1 {

    public int cuttingRope(int n) {

        int[] dp = new int[n + 1];
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i - 1; j++) {
                dp[i] = Math.max(Math.max(dp[j] * (i - j), j * (i - j)), dp[i]);
            }
        }
        return dp[n];
    }

    /**
     * 思路二：可以优化动态规划，j不用从1遍历到n-1。
     *
     * 思路三：数学知识
     * 数论
     *
     * 任何大于1的数都可由2和3相加组成（根据奇偶证明）
     * 因为2*2=1*4，2*3>1*5, 所以将数字拆成2和3，能得到的积最大
     * 因为2*2*2<3*3, 所以3越多积越大 时间复杂度O(n/3)，用幂函数可以达到O(log(n/3)), 因为n不大，所以提升意义不大，我就没用。 空间复杂度常数复杂度O(1)
     */
}
