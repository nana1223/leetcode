package jianzhi_offer;

import java.util.HashMap;
import java.util.Map;

/**
 * 剑指 Offer 48. 最长不含重复字符的子字符串
 * <p>
 * 思路：
 * <p>
 * 1.状态就是字符位置，选择就是当前字符是否有重复
 * 2.dp[i] 表示 以i为结尾的无重复最长子串的长度
 * 3.
 * 4.状态转移
 * <p>
 * 方法：动态规划 + 哈希表
 * 用哈希表记录：各字符最后一次出现的位置。这样可以方便的获取左边界
 * <p>
 * 理解：
 * 想了好久，把自己的理解总结下，如果有错误还请各位大佬指正：
 * <p>
 * K神的状态定义中，dp[ j ]指的是以字符s[ j ]结尾的字符串的长度。注意，这个字符串需要尽可能的长，且不能含有重复字符。
 * <p>
 * 我们可以记为字符串sub[ j ], 该字符串以字符s[ j ]结尾，长度为dp[ j ]。
 * <p>
 * 这样就比较好理解状态转移方程了。固定右边界 j ，同时定义从边界 j 往左侧距离最近的相同字符的索引为 i 。
 * <p>
 * 以字符s[ j - 1 ]结尾的字符串记录为sub[ j - 1]，其长度为dp[ j - 1 ]，注意sub [ j - 1]中字符不重复。 我们看索引 j 的情况：在 j 的左侧寻找一个重复的字符s [ i ],那么索引 i 可能在字符串sub[ j - 1]的区间内，也可能在字符串sub[ j - 1]的左边界更左侧才有可能寻找到。这样就需要分两种情况考虑。
 * <p>
 * 如果字符 s[ i ] 在子字符串 sub[ j − 1 ] 区间之外，也就是更左侧, 那么dp[ j - 1 ] < j - i，这种情况下，由于sub [ j - 1]中字符不重复，且当前最长，所以以s[ j ]为结尾的字符串只需要在子字符串 sub[ j − 1 ]后面接上这个字符s[ j ]就可以了，其长度dp [ j ] = dp[ j - 1 ] + 1;
 * <p>
 * 如果字符 s[ i ] 在子字符串 sub[ j− 1 ] 区间之中，必然dp[ j−1 ] ≥ j − i，这种情况下，由于我们需要寻找以s[ j ]结尾且最长的字符串，那么sub[ j ]的左边界只能是 i 了，其长度 dp[ j ] = j − i 。
 * <p>
 * 下面举个例子，比如“abcdbaa”，索引从0开始。 我们容易得到，当 j = 4时，以s[4]结尾字符串sub[4] = “cdb”的 长度dp[4] =3。 接下来我们看 j +1的情况。根据定义，sub[4]字符串中的字符肯定不重复，所以当 j = 5时，这时距离字符s[5]的左侧的重复字符a的索引 i = 0， 也就是说s[ 0 ]在子字符串sub[ 4 ]之外了，以s[5]结尾的字符串自然在sub[4]的基础上加上字符s[5]就构成了新的最长的不重复的子串sub[5]，长度dp[5] = dp[4] + 1; 接下来我们继续看 j =6的情况，这时s[6]的左侧重复字符a的索引 i = 5，该重复字符在sub[ 5 ]中。新的最长不重复的字串sub[6]左边界以 i 结尾，长度dp[6] = j - i = 1。
 */
public class Solution48 {

    public int lengthOfLongestSubstring(String s) {
        int res = 0;
        int temp = 0;
        Map<Character, Integer> dic = new HashMap<>();

        for (int j = 0; j < s.length(); j++) {
            //获取索引i
            int i = dic.getOrDefault(s.charAt(j), -1);
            //更新哈希表
            dic.put(s.charAt(j), j);
            //
            temp = temp < j - 1 ? temp + 1 : j - i;
            res = Math.max(res, temp);
        }

        return res;
    }
}
