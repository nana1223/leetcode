## 一、子序列类型问题
### 1、什么时候用动态规划
- 一旦涉及到子序列和最值，那几乎可以肯定，考察的是动态规划技巧，时间复杂度一般都是 O(n^2)。
 （原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着？）
### 2、用动态规划的基本思路历程
1. 先定义dp数组
2. 找到base case 
3. 针对具体的i j 看看怎么状态转移 列出状态转移方程  
4. 看有没有重叠子问题优化加备忘录
### 3、用动规的两种思路模板（dp数组的两种定义思路）
1. 第一种思路是一个一维的dp数组
- 这个思路中dp数组的定义是：在子数组arr[0…i]中，要求的子序列（最长递增子序列）的长度是dp[i]
~~~java
int n =  array.length;
int[] dp = new int[n];
for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j]+…)    
    }
}
~~~
- 例题 300最长递增子序列 53最大子数组和
2. 第二种思路是一个二维的dp数组
- 当涉及到两个字符串/数组的子序列时，会用到这种思路；如1143最长公共子序列 72编辑距离

  dp数组的定义：在子数组arr1[0…i]和子数组arr2[0…j]中，我们要求的子序列长度为dp[i][j]
- 这种思路也可以用于只涉及一个字符串/数组的情形；如516回文子序列问题

  dp数组的定义：在子数组arr[i…j]中，我们要求的子序列的长度为dp[i][j]
