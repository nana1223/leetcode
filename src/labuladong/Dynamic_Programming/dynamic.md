## 一、子序列类型问题
### 1、什么时候用动态规划
- 一旦涉及到子序列和最值，那几乎可以肯定，考察的是动态规划技巧，时间复杂度一般都是 O(n^2)。
 （原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着？）
### 2、用动态规划的基本思路历程
1. 先定义dp数组
2. 找到base case 
3. 针对具体的i j 看看怎么状态转移 列出状态转移方程  
4. 看有没有重叠子问题优化加备忘录
- **动态规划算法本质上就是穷举「状态」，然后在「选择」中选择最优解**。
~~~java
for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
        for ...
        dp[状态1][状态2][...] = 择优(选择1，选择2...)
~~~
### 3、用动规的两种思路模板（dp数组的两种定义思路）
1. 第一种思路是一个一维的dp数组
- 这个思路中dp数组的定义是：在子数组arr[0…i]中，要求的子序列（最长递增子序列）的长度是dp[i]
~~~java
int n =  array.length;
int[] dp = new int[n];
for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j]+…)    
    }
}
~~~
- 例题 300最长递增子序列 53最大子数组和
2. 第二种思路是一个二维的dp数组
- 当涉及到两个字符串/数组的子序列时，会用到这种思路；如1143最长公共子序列 72编辑距离

  dp数组的定义：在子数组arr1[0…i]和子数组arr2[0…j]中，我们要求的子序列长度为dp[i][j]
- 这种思路也可以用于只涉及一个字符串/数组的情形；如516回文子序列问题

  dp数组的定义：在子数组arr[i…j]中，我们要求的子序列的长度为dp[i][j]
## 二、背包问题
### 1、背包问题是什么及种类
- 背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。
- 背包问题的种类：

    0/1背包问题、完全背包问题、多重背包问题、混合三种背包问题、二维费用背包问题、分组背包问题、有依赖的背包问题、求背包问题的方案总数。

    其中，最基础的是0/1背包问题。作为动态规划的典型问题，其状态转移方程往往需要认真理解并能自行推出。

### 2、0-1背包问题
#### 1. 问题描述
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

- 题目就是这么简单，一个典型的动态规划问题。这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历。
#### 2. 解题套路
- 第一步：明确**状态**和**选择**。

    先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。所以状态有两个，就是「背包的容量」和「可选择的物品」。

    再说选择，也很容易想到啊，对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」嘛。
    ~~~java
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 择优(选择1，选择2...)
    ~~~
- 第二步：明确 **dp 数组**的定义。

  首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 dp 数组。

    dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。

    比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。
- 第三步：**base case**：根据这个定义，我们想求的最终答案就是 dp[N][W]。base case 就是 dp[0][..] = dp[..][0] = 0
- 第四步：根据**选择**，思考状态转移的逻辑

  如果你没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。

    如果你把这第 i 个物品装入了背包，那么 dp[i][w] 应该等于 val[i-1] + dp[i-1][w - wt[i-1]]。
- 最后把伪码翻译成代码，再处理一些边界情况，比如w - wt[i-1] 可能小于 0 导致数组索引越界
~~~java
int knapsack(int W, int N, int[] wt, int[] val) {
    assert N == wt.length;
    // base case 已初始化
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i - 1] < 0) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = Math.max(
                    dp[i - 1][w - wt[i-1]] + val[i-1], 
                    dp[i - 1][w]
                );
            }
        }
    }
    
    return dp[N][W];
}
~~~
- 例题416 分割等和子集
### 3、完全背包问题
- 相比0-1背包最大的区别就是：每个物品的数量是无限的
- 例题518. 零钱兑换 II
- 完全背包最好懂的文章： https://leetcode.cn/problems/coin-change-ii/solution/by-flix-e1vv/

# 三、动态规划总结
1. 关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？
2. dp 数组的遍历顺序是怎么确定的，主要是根据 base case，以 base case 为起点，逐步向结果靠近。

# 四、贪心算法问题
- 什么是贪心算法呢？**贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高**。

- 比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

  - 什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。

    比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。
  
    然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，