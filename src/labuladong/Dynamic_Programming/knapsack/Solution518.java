package labuladong.Dynamic_Programming.knapsack;

/**
 * 518. 零钱兑换 II
 * 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
 * 假设每一种面额的硬币有无限个。
 * <p>
 * 转换成背包问题：
 * 有一个背包，最大容量为 amount，有一系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？
 * <p>
 * 解题思路：
 * 1、定义状态和选择：状态就是背包的容量和可选择的物品；选择就是装进背包或者不装进背包
 * <p>
 * 2、明确dp数组的定义：
 * 首先看刚才的状态有2个，所以需要一个二维数组dp。
 * dp[i][j]定义：若只使用coins的前i个硬币的面值（可以重复使用），若想凑出金额j，有dp[i][j]种凑法。（i从1开始）
 * <p>
 * 3、定义base case：dp[0][..] = 0, dp[..][0] = 1。
 * i = 0 代表不使用任何硬币面值，这种情况下显然无法凑出任何金额；j = 0 代表需要凑出的目标金额为 0，那么什么都不做就是唯一的一种凑法。
 * <p>
 * 4、找状态转移关系【注意找状态转移关系可以根据[选择]（即是否进背包）】
 * 1）若当前第i个硬币进背包，dp[i][j] 应该等于 dp[i][j-coins[i-1]]。
 * 2）若当前第i个硬币不进背包，dp[i][j]应该等于dp[i-1][j]
 * 而我们想求的 dp[i][j] 是「共有多少种凑法」，所以 dp[i][j] 的值应该是以上两种选择的结果之和！！！
 * <p>
 * 最终想得到的答案就是 dp[N][amount]，其中 N 为 coins 数组的大小。
 * <p>
 * 疑问：不是说可以重复使用硬币吗？那么如果我确定「使用第 i 个面值的硬币」，我怎么确定这个面值的硬币被使用了多少枚？
 * 因为：dp数组定义时候就包含重复使用的情况。即若只使用前 i 个物品（可以重复使用），当背包容量为 j-coins[i-1] 时，有 dp[i][j-coins[i-1]] 种方法可以装满背包。
 *
 * 法二：压缩dp数组成一维，降低空间复杂度
 */
public class Solution518 {

    public int change(int amount, int[] coins) {

        //1.定义dp数组：dp[i][j]表示只使用coins的前i个硬币可以重复使用，若想凑出金额j，有dp[i][j]种凑法（i从1开始）
        int[][] dp = new int[coins.length + 1][amount + 1];
        //2.base case
        for (int i = 0; i < coins.length + 1; i++) {
            //要凑0元，就什么都不选一种凑法
            dp[i][0] = 1;
        }
        //3.状态转移
        for (int i = 1; i < coins.length + 1; i++) {
            for (int j = 1; j < amount + 1; j++) {
                if (j - coins[i - 1] < 0) {
                    //再凑就超金额了，所以不凑硬币i
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
                }
            }
        }
        return dp[coins.length][amount];
    }
}
