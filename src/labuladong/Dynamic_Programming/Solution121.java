package labuladong.Dynamic_Programming;

/**
 * 121. 买卖股票的最佳时机
 * 动态规划算法本质上就是穷举「状态」，然后在「选择」中选择最优解。
 * <p>
 * 1. 这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（用 1 表示持有，0 表示没有持有）。
 * 然后用一个三维数组就可以装下这几种状态的全部组合
 * dp[i][k][0 or 1]
 * 0 <= i <= n - 1, 1 <= k <= K。（n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票）
 * 比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易
 * <p>
 * 2.根据选择列出状态转移方程
 * 1）今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：
 * 1、我昨天就没有持有，且截至昨天最大交易次数限制为 k；然后我今天选择 rest，所以我今天还是没有持有，最大交易次数限制依然为 k。
 * 2、我昨天持有股票，且截至昨天最大交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最大交易次数限制依然为 k。
 * dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
 * <p>
 * 2）今天我持有着股票，最大交易次数限制为 k，那么对于昨天来说，有两种可能，我从这两种可能中求最大利润：
 * 1、我昨天就持有着股票，且截至昨天最大交易次数限制为 k；然后今天选择 rest，所以我今天还持有着股票，最大交易次数限制依然为 k。
 * 2、我昨天本没有持有，且截至昨天最大交易次数限制为 k - 1；但今天我选择 buy，所以今天我就持有股票了，最大交易次数限制为 k。
 * dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
 * <p>
 * 注意：状态 k 的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。
 * 如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为 k，那么昨天的最大交易次数上限必须是 k - 1。
 * <p>
 * 3.列base case
 * dp[-1][...][0] = 0
 * 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。
 * <p>
 * dp[-1][...][1] = -infinity
 * 解释：还没开始的时候，是不可能持有股票的。
 * 因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
 * <p>
 * dp[...][0][0] = 0
 * 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。
 * <p>
 * dp[...][0][1] = -infinity
 * 解释：不允许交易的情况下，是不可能持有股票的。
 * 因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
 * <p>
 * 对于本题：121来说：k=1只允许交易一次
 */
public class Solution121 {

    /**
     * 法一：暴力解法（会超时）
     */
    public int maxProfit1(int[] prices) {
        int res = 0;
        for (int i = 0; i < prices.length; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int tempRes = prices[j] - prices[i];
                res = Math.max(res, tempRes);
            }
        }
        return res;
    }

    /**
     * 法二：动态规划
     */
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];

        for (int i = 0; i < n; i++) {
            //1.base case
            if (i - 1 == -1) {
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            //2.状态转移
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            //注意这里的细节：-prices[i]
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
        }
        //所求
        return dp[n - 1][0];
    }

    public static void main(String[] args) {
        int[] pr = {7, 1, 5, 3, 6, 4};
        Solution121 solution121 = new Solution121();
        solution121.maxProfit(pr);
    }
}
