package jianzhi2_zhuanxiang;

/**
 * 剑指 Offer II 003. 前 n 个数字二进制中 1 的个数
 * 给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。
 * <p>
 * 【思路】：分奇偶数来理解二进制中1的个数
 * 1. 如果正整数 i 是一个偶数，那么 i 相当于将 i/2 左移一位的结果，因此偶数 i 和 i/2 的二进制形式 1 的个数是一样的
 * 2. 如果 i 是奇数，那么 i 相当于将 i/2 左移一位之后再将最右边的位设为 1 的结果，因此奇数 i 比 i/2 的二进制形式 1 的个数多 1 个
 * 然后优化：
 * 【位运算比除法和求余运算更高效】
 * i >> 1 等价于 i / 2;
 * i & 1 等价于 i % 2;
 * <p>
 * 【反思】：其实也是动态规划的思路：就是i和i/2有关，要由上一步来推出
 */
public class Solution3 {

    public int[] countBits(int n) {
        int[] res = new int[n + 1];
        for (int i = 0; i < n + 1; i++) {
            //更低效但易理解的写法：res[i] = res[i/2] + i%2 ;      【注意】：位运算要加()确保优先级
            res[i] = res[i >> 1] + (i & 1);
        }
        return res;
    }
}
